export { loadPageCode };
import { assert, assertDefaultExportUnknown, assertUsage, objectAssign } from '../utils.js';
import pc from '@brillout/picocolors';
async function loadPageCode(pageConfig, isDev) {
    if (pageConfig.isLoaded &&
        // We don't need to cache in dev, since Vite already caches the virtual module
        !isDev) {
        return pageConfig;
    }
    const codeFiles = await pageConfig.loadCodeFiles();
    // TODO: remove?
    // pageConfig.configValuesOld = pageConfig.configValuesOld.filter((val) => !val.definedByCodeFile)
    const addConfigValue = (configName, value, filePath, exportName) => {
        /* TODO
        assert(!isAlreadyDefined(val.configName), val.configName) // Conflicts are resolved upstream
        */
        pageConfig.configValues[configName] = {
            value,
            definedAtInfo: {
                filePath,
                fileExportPath: [exportName]
            }
            /* TODO: remove?
            definedByCodeFile: true
            */
        };
        assertIsNotNull(value, configName, filePath);
    };
    codeFiles.forEach((codeFile) => {
        if (codeFile.isPlusFile) {
            const { codeFileExports, codeFilePath } = codeFile;
            if (codeFile.configName !== 'client') {
                assertDefaultExportUnknown(codeFileExports, codeFilePath);
            }
            Object.entries(codeFileExports).forEach(([exportName, exportValue]) => {
                const isSideExport = exportName !== 'default'; // .md files may have "side-exports" such as `export { frontmatter }`
                const configName = isSideExport ? exportName : codeFile.configName;
                if (isSideExport && configName in pageConfig.configValues) {
                    // We can't avoid side-export conflicts upstream. (Because we cannot know about side-exports upstream at build-time.)
                    // Side-exports have the lowest priority.
                    return;
                }
                addConfigValue(configName, exportValue, codeFilePath, exportName);
            });
        }
        else {
            const { configName, codeFilePath, codeFileExportValue, codeFileExportName } = codeFile;
            addConfigValue(configName, codeFileExportValue, codeFilePath, codeFileExportName);
        }
    });
    /* TODO Remove? Conflicts are already handled
    const codeFileExports: ({ configVal: ConfigValueOld } & (
      | { isPlusFile: true; isSideExport: boolean }
      | { isPlusFile: false; isSideExport: null }
    ))[] = []
    codeFileExports
      .sort(
        lowerFirst((codeFileExport) => {
          const { isPlusFile, isSideExport } = codeFileExport
          if (isPlusFile) {
            if (isSideExport) {
              return 2
            } else {
              return 0
            }
          } else {
            return 1
          }
        })
      )
      .forEach((codeFileExport) => {
        const alreadyDefined = configValuesOld.find(
          (configVal) => codeFileExport.configVal.configName === configVal.configName
        )
        if (!alreadyDefined) {
          configValuesOld.push(codeFileExport.configVal)
        }
      })
    */
    objectAssign(pageConfig, { isLoaded: true });
    return pageConfig;
}
function assertIsNotNull(configValue, configName, codeFilePath) {
    assert(!codeFilePath.includes('+config.'));
    assertUsage(configValue !== null, `Set ${pc.cyan(configName)} to ${pc.cyan('null')} in a +config.h.js file instead of ${codeFilePath}`);
}
